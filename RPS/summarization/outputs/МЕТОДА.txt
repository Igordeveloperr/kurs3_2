 Лабораторный практикум
Допущено учебно-методическим
 объединением вузов
 по университетскому
политехническому образованию
в качестве учебного пособия
для студентов , обучающихся
по специальности  230101
«Вычислительные машины ,
комплексы , системы и сети »
Киров  2007Печатается по решению редакционно-издательского совета Вятского
государственного университета
УДК  004.424.8(07)
К21
Караваева О.В . Лабораторный практикум : учебное пособие  – Киров : Изд-во ВятГУ ,
2006. – 114 с.
В учебном пособии предлагается цикл из четырех лабораторных работ :
изучение архитектуры процессора , работа с прерываниями на языке Ассемблера
для управления клавиатурой и монитором , изучение структуры жесткого и
логического дисков и работа с системными областями дисков в файловой системе
FAT. Пособие рассчитано на студентов , обучающихся по специальности  230101
(220100) « Вычислительные машины , комплексы , системы и сети » при изучении
дисциплин  "Системное программное обеспечение " и "Операционные системы "
Оно может быть полезным студентам других специальностей при знакомстве с
использованием языка Ассемблера для управления устройствами ввода-вывода ,
дисками и файлами . Работа в  Windows .................................................................................. 50
Windows 95/98/ME ....................................................................................... 50
Windows NT/2000/XP/2003/Vista................................................................. 56
Вопросы для самопроверки ................................................................................ 59
Примерные задания для выполнения лабораторной работы ............................ 60
Библиографический список ................................................................................... 63
Приложение ............................................................................................................ 644
ПРЕДИСЛОВИЕ
Специалист по направлению  «Информатика и вычислительная техника »
должен не только изучить теоретические принципы построения и
функционирования операционных систем и основы разработки системного
программного обеспечения , но также уметь разрабатывать самостоятельно
отдельные компоненты операционной системы , или системные утилиты . Поэтому при изучении дисциплины  «Системное программное обеспечение »
предлагается использовать операционную систему  Windows98 с файловой
системой  FAT (FAT12, FAT16, FAT32) для изучения на практике разделов
«Управление устройствами », « Управление вводом-выводом » и «Управление
файлами и дисками ». Общий
объем дисциплины  170 часов , который обычно распределяется следующим
образом : лекции  – 51 час, лабораторные занятия  – 34 часа, самостоятельная
работа  – 81 час. В соответствии с этим всю дисциплину  «Системное
программное обеспечение » можно условно разделить на две большие части :
-управление задачами , памятью , вводом-выводом и файлами ;
-формальные языки , грамматики и компиляторы . В
первой изучается управление стандартными символьными устройствами , во
второй  – управление дисками и файлами . В первую часть входят две четырехчасовые лабораторные работы :
-изучение логической организации программы на языке Ассемблера и
архитектуры памяти процессора , а также знакомство с работой Турбо
отладчика на примере готовой программы ;
- написание программы на языке Ассемблера для управления клавиатурой
и монитором под управлением операционной системы  MS DOS по
индивидуальному заданию . После изучения структуры логического диска студентам необходимо
написать программу на языке Ассемблера , в которой они должны , выполнить
работу по изучению системных областей логического диска , например , найти
файл на диске , используя информацию из загрузочного сектора логического
диска , области  FAT и корневого каталога .7
Во второй лабораторной работе решается та же задача организации работы
с системными областями дисков , но под управлением одной из версий
операционной системы  Windows:  Windows 95/98/ME или Windows
NT/2000/XP/2003/Vista. Турбо отладчик поддерживает полный синтаксис выражений Ассемблера ,
обеспечивает работу с константами всех типов , которые используются в
Ассемблере  (byte, word, длинные , составные , с плавающей точкой , вещественные ,
с двойной и расширенной точностью ). С помощью данного окна  CPU можно проверять и модифицировать байты
данных непосредственно в шестнадцатеричном виде , анализировать стек вызова
функций , проверять и модифицировать регистры центрального процессора  (ЦП) и
его флаги . Окно  CPU ( ЦП) можно создать , выбрав команду основного меню  View/CPU
(Обзор/Центральный процессор ). Это предоставляет удобный способ просматривать код , данные
или стек  (соответствующие текущему положению курсора ) "на нижнем уровне ". В каждой из пяти областей окна  CPU ( область кода , область данных ,
область стека , область регистров и область флагов ) имеется локальное меню . Адрес выводится либо в виде шестнадцатеричного значения
сегмента и смещения , либо со значением сегмента , замененным именем регистра
CS ( если значение сегмента совпадает с текущим значением регистра  CS). Эта
область имеет ширину  (которая может переключаться или настраиваться ),
достаточную для вывода всех образующих инструкцию байт . После выбора команды Goto ( Переход ) выводится подсказка для ввода
нового адреса , на который нужно перейти . Можно ввести адрес , выходящий за
пределы программы , что позволяет проверить базовую систему ввода-вывода
(BIOS), внутренние области  DOS и резидентные утилиты . Эту команду можно
использовать с инструкциями  CALL, JMP, инструкциями условных переходов
(JZ, JNE, LOOP, JCXZ и т.д .) Команда  Caller  (Вызывающая программа ) позиционирует на инструкцию ,
по которой была вызвана текущая подпрограмма или прерывание . Команда  Search  (Поиск ) позволяет вводить инструкцию или список байт ,
которые нужно найти . Например , поиск следующих инструкций проблемы
не представляет :
PUSH DX
POP [DI+4]
ADD AX,100
а попытка поиска следующих инструкций может привести к непредсказуемым
результатам :
JE 123
CALL MYFUNC
LOOP $-10
Вместо инструкции можно вводить также список байт . Команда  Mixed (Чередование ) позволяет выбрать один из трех способов
вывода на экран дисассемблированных инструкций и исходного кода :
-No (Нет )исходный код не выводится , выводятся только деассемблированные
инструкции ;
-Yes ( Да) перед первой дисассемблированной инструкцией , соответствующей
данной строке , выводится строка исходного кода . Область устанавливается в
данный режим , если исходный модуль написан на языке высокого уровня ;
-Both ( Оба) Для тех строк , которым соответствует исходный код ,
дисассемблированные строки заменяются строками исходного текста . При повторном запуске программы выполнение
начнется с этого адреса .11
Команда  Previous  (Предыдущий ) восстанавливает область кода в то
состояние  (позицию ), которое она имела до выполнения команд  Goto, Follow или
Caller. При использовании команды  Previous позиция окна кода запоминается ,
поэтому повторное использование этой команды приводит к переключению
между двумя адресами  (туда и обратно ). Формат этой области зависит от режима вывода , выбранного с помощью
команды локального меню  Display As ( Вывести как  ...). Устанавливает область кода под курсором в
ближний адрес
Far Code ( Дальний код ) Следует по цепочке указателя  (дальний тип ).12
Устанавливает область кода под курсором в
дальний адрес
Offset to Data( Смещение
данных )Устанавливает область кода в ближний адрес под
курсором
Base Segment:0 to Data Устанавливает область данных в  (Базовый сегмент
данных ) начало сегмента , который содержит адрес
под курсором
Previous ( Предыдущий ) Выводит на экран данные по последнему адресу
Display As ( Режим вывода )
- Byte ( Байт )
- Word ( Слово )
- Long ( Длинный )На экран выводятся :
шестнадцатеричные байты ;
шестнадцатеричные слова ;
шестнадцатеричные  32-битовые длинные слова
Comp (C ложный ) На экран выводятся  8-байтовые целые
Float( С плавающей
точкой )На экран выводятся короткие  (4-байтовые ) числа с
плавающей точкой
Real ( Вещественный ) На экран выводятся  6-байтовые числа с плавающей
точкой
Окончание табл . Extended( С расширенной
точностью )На экран выводятся  10- байтовые числа с
плавающей точкой
Block ( Блок )
Clear ( Очистка )
Move ( Перемещение )
Set ( Присваивание )
Read ( Считывание )
Write ( Запись )Работа с блоком :
очищает блок памяти ;
перемещает блок в памяти ;
присваивает блоку памяти значение  (побайтно );
выполняет чтение из файла в память ;
записывает из памяти в файл
Вокне  Registers ( Регистры ) выводится содержимое регистров и флагов
ЦП. Данное окно содержит две области , которые эквивалентны областям
регистров и флагов окна  CPU ( ЦП). Подсветив имя функции в
стеке и нажав  Ctrl-I, открывается окно  Variables ( Переменные ), в котором
выводятся переменные , глобальные относительно программы , переменные ,
локальные относительно функции , и аргументы вызова функции . Follow ( Следовать ) Выводит код , на который указывает текущий
элемент
Previous ( Предыдущий ) Восстанавливает на экране вывод по
последнему адресу
Change ( Изменение ) Позволяет редактировать информацию14
2. Постановка задачи
Основной целью выполнения лабораторных работ первой части является :
-знакомство со структурой программы и с работой Турбо отладчика на примере
готовой программы , написанной на языке Ассемблера ;
-закрепление теоретических знаний по основным приемам программирования на
языке Ассемблера и работе со стандартными символьными устройствами с
использованием прерываний  DOS и BIOS. При работе в реальном режиме процессора компьютер оснащен  20-
разрядной шиной адреса и  16-разрядной шиной данных , это означает , что имеется
возможность адресоваться к  1 Мбайту памяти . Диапазон физических адресов для
20-разрядной шины можно записать следующим образом :
00000h <= [ физический адрес ] <= FFFFFh
Однако все регистры процессора являются  16- разрядными , поэтому
возникает проблема представления  20-разрядного физического адреса памяти при
помощи содержимого  16-разрядных регистров . Пять регистров
– указатели и индексы  – хранят смещения , используемые для обращения к
сегментам памяти . Регистры общего назначения , или арифметические регистры , обозначаются
AX, BX, CX и DX ( рис.2.2). Левый байт является
старшей частью  (high), а правый  – младшей частью  (low) и соответственно
обозначаются старшие  – AH, BH, CH и DH, младшие  – AL, BL, CL и DL.0 15
Смещение0 15
Адрес сегмента 0000
0 19
Исполнительный адрес+
=
Рис. Каждый сегментный регистр  (рис.2.3) обеспечивает адресацию памяти
объемом  64 Кбайта , которая называется текущим сегментом . Регистр  SP ( указатель вершины стека ) обеспечивает использование стека в
памяти , позволяет временно хранить адреса и данные . Регистры  SI (индекс источника ) и DI ( индекс приемника ) используются для
формирования сложных адресов , состоящих из смещения начала блока данных в
сегменте и относительного смещения элемента данных внутри блока . Наиболее важное использование стека  – это запись адреса
программы , откуда была вызвана подпрограмма , и параметров , передаваемых
подпрограммам . Программные прерывания инициируются командой  INT, аппаратные  – внешними
событиями , асинхронными по отношению к выполняемой программе . Стековый сегмент  – это область памяти , которая используется для
временного хранения промежуточных данных , необходимых для
информационной связи программ или процедур . Все программы , написанные на языке Ассемблера , имеют схожую
структуру :
.386 ;это ассемблерная директива , говорящая
;ассемблеру использовать набор операций для
;процессора  80386. .model small ;это ассемблерная директива , определяющая
;модель памяти программы . .DATA ;объявление сегмента данных
 <Инициализируемые данные >
 ......
.CODE ;объявление кодового сегмента
 <метка >
 <Код>
 ......
end < метка > ;конец программы
Объявление сегментов позволяет Ассемблеру проследить , какие из
сегментов доступны через сегментные регистры . 2.9 описаны :
-сегмент данных  (строки  2 – 3), содержащий описание сообщения для
вывода на экран ;
-сегмент стека  (строка  4) размером  256h байтов ;
-кодовый сегмент  (строки  5 – 16), в котором выводится сообщение на
экран  (строки  9 – 11), вводится символ без отображения на экране  (строки
12 – 13) и завершается работа программы  (строки  14 – 15). В строках  7 и 8
в регистр  DS заносится адрес сегмента данных , так как при загрузке
программы в оперативную память система не загружает регистр  DS.22
Команда Комментарии№
стро -
ки
.model small ;модель памяти 1
.data ;сегмент данных 2
message db 'Symbol:
$';выводимое приглашение для ввода
;символа3
.stack 256h ;размер стека   256h байт 4
.code ;описание сегмента кода 5
main: ;начало основной программы 6
mov ax,@data ;загрузка адреса 7
mov ds,ax ;сегмента данных 8
lea dx,message ;загрузка эффективного адреса
;сообщения в регистр  DX9
mov ah,09h ;функция вывода строки ,
;завершающейся знаком  $, на экран
;(регистр  DХ содержит адрес
;сообщения )10
int 21h ;прерывание  DOS 11
mov ah,0 ;считываем символ без эха 12
int 16h ;прерывание  BIOS 13
mov ah,4ch ;функция для выхода в ОС 14
int 21h ;прерывание  DOS 15
end main ;конец основной программы 16
Рис. В его функции входит распознавание нажатой клавиши и
помещение закрепленного за ней кода в свой выходной регистр  (порт ), обычно с
номером  60h. При нажатии клавиши программа  INT 09h считывает из порта  60h ее скэн -
код нажатия и по таблице трансляции скэн-кодов в коды  ASCII формирует
двухбайтовый код , старший байт которого содержит скэн-код , а младший  – код
ASCII. В хвостовом указателе  (40:1Ch) хранится адрес первой свободной
ячейки , в головном указателе  (40:1Ah) – адрес самого старого кода , принятого с
клавиатуры и еще не востребованного программой . Операционная система предоставляет несколько способов ввода данных с
клавиатуры :
 – обращение к клавиатуре как к файлу , с помощью прерывания  DOS INT
21h с функцией  3Fh;
 – использование группы функций  DOS INT 21h из диапазона  1h...Ch,
обеспечивающих посимвольный ввод с клавиатуры в разных режимах ;
 – посимвольный ввод путем обращения непосредственно к драйверу  BIOS
с помощью прерывания  INT 16h.24
2.7. Программные средства обслуживания экрана включают в себя видеоадаптер
BIOS, к которому можно обратиться из прикладной программы с помощью
прерывания  Int 10h и который обеспечивает нижний уровень управления  (вывод
символов , работа с курсором , переключение режимов видеоадаптера и т.д . ), а
также программы  DOS, активизируемые с помощью прерывания  Int 21h и
предоставляющие более высокий уровень сервиса в текстовом режиме . Любой из этих режимов можно инициировать
конструкцией типа :
 mov ah,00h
 mov al,Mode ;Номер видеорежима
 int 10h
В текстовом режиме изображение состоит обычно из  25 строк по  80
символов в строке . Для адаптеров типа  SVGA был разработан единый стандарт для видеокарт ,
получивший название  VESA (Video Electronics Standards Association). Для инициализации  VESA режима необходимо использовать следующую
конструкцию :
mov ax,4F02h
mov bx,VESA_mode ; Номер  VESA режима
int 10h
Перед вызовом функции рекомендуется проверить , поддерживает ли
адаптер этот режим :
mov ax,4F01h25
mov cx,VESA_mode ; номер  VESA  режима
mov di,buffer
int 10h
Пара регистров  ES:DI содержит указатель на буфер размером  256 байт для
таблицы описания режима , где в случае успешного завершения находятся
атрибуты режима , атрибуты окон А и В и другая информация . Операционная система предоставляет несколько способов вывода текстовой
информации на экран :
 – обращение к экрану как к файлу с помощью прерывания  DOS INT 21h с
функцией  40h;
- использование группы функций  DOS INT 21h из диапазона  1h...Ch,
обеспечивающих посимвольный вывод и вывод строк ;
 – вывод путем обращения непосредственно к драйверу  BIOS с помощью
прерывания  INT 10h. Покомандное выполнение программы осуществляется с помощью
функциональных клавиш  F7 ( с заходом в процедуры ) и F8 ( без захода в
процедуры ).26
Пока не загружен регистр  DS адресом сегмента данных программы ,
содержимое этого сегмента увидеть сложно . При выполнении следующей команды с адресом  CS:0005 в
регистр  DX загружается смещение строки message для того , чтобы вывести эту
строку на экран функцией  09 ( команда с адресом  CS:0009 загружает номер
функции в регистр  AH) прерывания  21h ( вызов прерывания  – команда с адресом
CS:000 В). .model small ;модель памяти
.data ;сегмент данных
message1 db 'Symbol: $' ;выводимое приглашение для ввода  ;символа
message2 db 0ah,0dh,'Stroka: $' ;выводимое приглашение для ввода  ;строки
message3 db 0ah,0dh,'Result: $' ;выводимая строка-результат
FullData STRUC ;описание структуры данных для  ;хранения
символов
one db 9 dup(36)
two db 10 dup(36)
three db 1 dup(36),36
FullData ENDS
FD FullData 1 dup(<>) ;выделяем память для структуры
.stack 256h ;определяем размер стека в  256h ; байт
.code ;описание сегмента кода
INPUT  proc near ;процедура для ввода символов
Xor di,di ;очищаем  DI-счетчик символов
m1: ;метка  m1
mov ah,0 ;считываем символ без эха
Int 16h ;функцией  BIOS
cmp al,0 ;проверка нажатой клавиши
Jne m3 ;если она нефункциональная , идем  ;на m3
mov ah,0
int 16h;в противном случае вызываем  ;снова эту же
функцию  BIOS
jmp m1 ;переходим на начало  (m1)
m3: ;метка  m3
cmp dx,1 ;проверяем на возможность обрыва  ;строки
(dx заполняется до  ;вызова функции )
Je m4 ;если флаг установлен , переход  ;на m4
cmp al,13 ;если нажата клавиша  Enter, то
Je quit ;переход на конец
m4: ;метка  m4
cmp al,33 ;проверяем , не является ли  ;введенный
символ управляющим
Jle m1 ;если он все-таки управляющий , ;переход на
m1 (нам не нужны  ;такие символы )
mov bx[di],al ;в противном случае записываем в  ;буфер
ввода  (описанную  ;структуру ) введенный29
символ
Inc di ;увеличиваем счетчик
mov ah,2 ;подготавливаем функцию для
mov dl,al ;вывода на экран
Int 21h ;прерывание  DOS
loop m1 ;все это выполняется в цикле
quit: ;метка  quit ( выход )
Ret ;возврат из подпрограммы
INPUT endp ;конец описания процедуры
MESSAGE proc near ;процедура для вывода сообщений
push ax ;сохраняем значение регистров  AX
push cx ;и CX
mov ah,09h ;вызываем функцию вывода строки ,
;завершающейся знаком  $ на экран   ;регистр
dx заполняется до  ;вызова процедуры )
Int 21h ;прерывание  DOS
pop cx ;восстанавливаем значения  ;регистров  CX
pop ax ;и AX
Ret ;возврат из подпрограммы
MESSAGE endp ;конец описания процедуры
main: ;основная программа
mov ax,@data ;загрузка адреса
mov ds,ax ;сегмента данных
Lea dx,message1 ;загрузка эффективного адреса  ;сообщения в
DX
call MESSAGE ;выводим сообщение
Lea bx,FD.three ;подготавливаем место , на ;которое будет
записан символ  ;для вставки
mov cx,1 ;количество символов  – 1
mov dx,1 ;флаг , говорящий о том , что ;ENTER не
будет учитываться
call INPUT ;вызов функции ввода символа
Lea dx,message2 ;загрузка эффективного адреса  ;сообщения в
DX
call MESSAGE ;выводим сообщение
Lea bx,FD.two ;подготавливаем место , на ;которое будет
записана строка  ;символов
mov cx,10 ;максимальный размер  – 10
Xor dx,dx ;ENTER будет учитываться
call INPUT ;вызов функции ввода символов
mov cx,di ;записываем в  CX количество  ;фактически30
введенных символов
 mov ch, 36 ;записываем символ для  ;заполнения
освободившегося  ;места в строке
mov ah,FD.three ;записываем символ для замены из
;структуры
Xor si,si ;чистим счетчики  SI
Xor di,di ;и DI
here: ;метка  here ( начало цикла  ;вставки )
mov al,offset FD.two[si] ;записываем в  AL введенные  ;символы по
порядку из строки
mov offset FD.two[si],ch ;заменяем освободившийся символ  ;(он уже
записан в  AL) на ;значение для замены  (он
;находится в  CH)
mov offset FD.one[di],ax ;записываем символы из регистра  ;AX
;(в младшем байте  – символ из  ;строки ,
старшем  – символ для  ;вставки )
add di,2 ;увеличиваем счетчик символов в  ;новой
строке  (со вставленным  ;символом ) на 2
Inc si ;счетчик считанных из строки  ;символов
увеличиваем на  1
loop here ;все это выполняем в цикле
Lea dx,message3 ;загрузка эффективного адреса  ;сообщения
;в регистр  DX
call MESSAGE ;выводим сообщение
Lea dx,FD ;загрузка эффективного адреса  ;сообщения
;в регистр  DX
call MESSAGE ;вывод результирующей строки
mov ax,4c00h ;функция для выхода в ОС
Int 21h ;функция  DOS
end main ;конец основной программы31
Результат выполнения программы представлен на рис . Первый символ  «0», остальные  – произвольные . Конец ввода  – ENTER. Конец ввода  – ENTER. Конец ввода  – ENTER. Полученную строку рассортировать по убыванию или возрастанию
в зависимости от запроса
5 Ввести символ и подсчитать количество единичных битов в
двоичном представлении символа
6 Ввести два символа , подсчитать количество ненулевых байтов в
символе и вывести символ с наибольшим количеством ненулевых
битов
7 Ввести строку символов и вывести на экран двоичное
представление третьего символа
8 Ввести номера строки и столбца и поместить туда курсор . символы вывести в  1-ю строку экрана ; 2-
й, 4-й, 6-й и т.д . Сформировать три новые строки : в 1-й
строке только цифры ; во 2-й строке  – буквы ; в 3-й – специальные
символы
12 Ввести три строки символов и удалить из этих строк символ ,
введенный с клавиатуры . При движении изменяется цвет строки
21 Ввести строку символов и сдвигать ее вверх и вниз по экрану ,
используя клавиши управления ↓ ↑
22 Ввести строку символов и сдвигать ее по экрану вверх , вниз , вправо
и влево , используя клавиши ← ↓ ↑ →
23 Изменить форму курсора , ввести строку символов , вывести ее в
обратном порядке . Посчитать количество символов в
каждой строке и вывести еще одну строку , количество символов в
которой рано сумме символов двух первых строках
27 Создать  2 страницы и сдвигать  0-ю вправо , 1-ю влево с помощью
клавиш ← → . Сдвигать  0-ю страницу вправо и вверх , 1-ю влево и вниз
30 Создать  «звездное небо », « звезда » – символ , введенный с
клавиатуры
31 Ввести строку символов . Конец ввода  – ENTER. Проверить , есть ли такой
символ в строке . Проверить , есть ли такой
символ в строке . Если нет , заменить все символы исходной
последовательности введенным символом
58 Вести строку символов с клавиатуры , используя прерывание  21h с
различными функциями :
-функция  01h c эхо;
-функция  07h без эхо ;
-функция  0Ah буферизованный ввод36
3. Распределение дискового пространства
Самый первый сектор жесткого диска  (сектор  1 стороны  0 цилиндра  0)
содержит главную загрузочную запись  (Master boot), занимающую один сектор и
включающую в себя часть программы начальной загрузки и таблицу разделов
диска . Каждому логическому диску ,
входящему в расширенный раздел , предшествует сектор , содержащий таблицу
логических дисков . В этой таблице указываются адреса и размеры данного и
следующего логических дисков . Четыре области логического диска  – запись начальной загрузки , таблица
распределения дискового пространства , основной каталог и область для данных  –
размещаются последовательно , начиная с сектора  0 (дорожка  0, сектор  1). Каждому логическому диску ,
входящему в расширенный раздел , предшествует сектор , содержащий таблицу
логических дисков . В этой таблице указываются адреса и размеры данного и
следующего логических дисков . Основное , что в нем содержится , – это короткая
программа , которая запускает процесс загрузки операционной системы с диска в
память . Байты  1 и 0
содержат инструкцию для перехода к исполнимой части программы  (обычно  jmp
2b), а байт  2 содержит  90h (NOP). 3.1
Смещение Длина Содержание
0Dh 1 байт Размер кластера в секторах  (1)
0Еh 1 слово Кол-во зарезервированных секторов в начале  (1)
10h 1 байт Количество копий  FAT (2)
11h 1 слово Количество элементов основного каталога  (E0h)
13h 1 слово Общее количество секторов диска  (2880)
15h 1 байт Идентификатор формата  (F0h)
16h 1 слово Размер  FAT в секторах  (9)
18h 1 слово Количество секторов на дорожке  (18)
1Аh 1 слово Количество поверхностей  (головок ) (2)
1Ch 4 байта Количество скрытых секторов
27h 4 байта Серийный номер тома
2Bh 11 байт Метка тома
 FAT32 дисководы содержат более зарезервированных секторов , чем
дисководы с  FAT12 или с  FAT16. Число зарезервированных секторов  – обычно
32, но может измениться . Так как в  FAT32 Блок Параметров  BIOS (BPB) имеет больший размер , чем
стандартный  BPB, то блок начальной загрузки на дисководах  FAT32 занимает
больше , чем 1 сектор . Таблица распределения дискового пространства39
Таблица распределения дискового пространства  (File Allocation table – FAT)
содержит информацию о расположении файлов , свободном пространстве на
дисках и неисправных блоках , а также идентификатор формата диска . Недостатком является постепенное фрагментирование диска при
активной работе с файловой системой  (создание и удаление файлов ) – файлы не
занимают непрерывные области , фрагментирование значительно снижает
быстродействие . Для дискеты  1.44 М идентификатор  F0, для
жесткого диска  – F8. Поскольку первые два элемента  FAT (0 и 1) используются идентификатором
формата диска , то нумерация фактических элементов начинается с  2. В этих случаях для
нахождения следующего элемента  FAT выполняют следующие вычисления :
1)умножается номер кластера из текущего элемента  FAT на 1,5;
2) результат  (округленный к меньшему целому числу ) используется как
смещение в  FAT, откуда считываются два байта ;
3) следующий элемент содержится в первых  12 битах при четном номере
кластера или в последних битах при нечетном номере . Для преобразования номера кластера в номер сектора нужно выполнить
следующее :
1)из номера кластера вычитается  2;40
2)результат умножается на количество секторов в одном кластере ;
3)к полученному результату добавляется количество секторов , занимаемых
системными областями . На дисководах с  FAT32,
корневой каталог  – обычная цепочка кластеров . Это позволяет корневому
каталогу расти так , как необходимо .... 15h 16h 17h 18h 19h 1Ah 1Bh ... 81h
F
A ... 02D 000 018 01B 000 FF7 081 ... FFF
T41
Для каждого файла на диске имеется один элемент в определенном каталоге . Для FAT32  элемент каталога отличается длиной номера начального
кластера , поэтому структура его элементов имеет несколько иной вид   (табл . Таблица  3.2
Элемент каталога  FAT12 и FAT16
Смещение Число байтов Содержание
00h 8 Имя файла в кодах  ASCII
08h 3 Расширение имени файла в кодах  ASCII
0Bh 1 Байт атрибутов файла
0Ch 10 Зарезервировано
16h 2 Время создания или последней модификации
18h 2 Дата создания или последней модификации
1Ah 2 Номер начального кластера файла
1Ch 4 Фактическая длина файла в байтах
Первый байт поля имени используется для обозначения трех специальных
случаев :
-значение  00Н в первом байте показывает , что этот элемент каталога никогда
не был использован . Так как каталог заполняется последовательно , это
означает , что и следующие за ним элементы не были использованы ;
-при удалении файла  DOS записывает Е5Н в первом байте
соответствующего элемента каталога . Но сам файл
продолжает существовать на диске , что позволяет соответствующим
программам восстановить удаленный файл , если элемент каталога или
кластеры файла в области данных не используются уже другим файлом ;
-значение  2ЕН (символ  ".") Если и второй байт содержит  2ЕН,
элемент описывает родительский каталог  (".."). Таблица  3.3
Элемент каталога  FAT32
Смещение Размер Значение
0 8 Имя файла в кодах  ASCII
8 3 Расширение имени файла в кодах  ASCII42
11 1 Атрибут
12 8 Зарезервировано
20 2 Номер начального кластера  (старшие разряды )
22 2 Время создания или последней модификации
24 2 Дата создания или последней модификации
26 2 Номер начального кластера  (младшие разряды )
28 4 Фактическая длина файла в байтах
Для файлов , которым не выделено места , и для метки тома поле номера
первого кластера содержит  0000 Н.
Байт атрибута определяет каждый файл , например , как системный или
скрытый и т.д . . . . . . . . . . . . 1  . . . . . 1  . . . . . 1  . . . . . 1  . . . . . 1  . . . . . . . . . . . . . . . . Установка младших
четырех битов этого байта  (значение  0Fh) задает элементу каталога атрибуты
“только для чтения ”, “скрытый ”, “системный ” и “метка тома ”. Для того чтобы исключить возможность , что какая-нибудь утилита
обслуживания диска уничтожит данные , разработчики ввели в  API функцию
“исключительного закрепления метки тома ” (exclusive volume lock), которую
приложение должно вызвать прежде , чем Windows позволит ему осуществить
прямую запись на диск  ( при помощи  MS-DOS прерываний  Int 13h и Int 26h). Каждый  32-байтный элемент , описывающий длинное имя файла , содержит
порядковый номер , защитный байт атрибута , значение типа и контрольную
сумму (рис. Поле
типа  идентифицирует элемент как  LONG_NAME_COMP ( элемент длинного
имени ) либо как  LONG_CLASS (32- байтный элемент , который содержит
информацию о классе для данного файла ). Работа в  DOS
В данном разделе будет рассмотрена работа с дисками в реальном режиме
как с использование прерываний  (сервисов ) BIOS, так и прерываний  (сервисов )
DOS. В классическом варианте использует систему адресации цилиндр -
головка-сектор , или C-H-S (Cylinder-Head-Sector). Дисковый
накопитель состоит из нескольких , насаженных на общий стержень , магнитных
поверхностей  – «блинов ». Данные на поверхность при вращении всего
комплекта  «блинов » заносятся по замкнутой окружности  – дорожке  (или
цилиндру  – комплект дорожек ), расположенных на разных поверхностях друг над
другом  (координата С ). Формат элемента каталога , в котором хранится длинное имя файла45
наконец , каждая дорожка разбита на некоторое количество секторов  (S-
координата ). Таким образом , каждый сектор можно задать трехразрядным числом :  C-H-
S. Сектор  – самый младший  «разряд » этого числа ; перенос из данного разряда  –
это переход на следующую поверхность  (головку ) внутри цилиндра . Перевести число из такой системы счисления в любую другую достаточно просто :
N = С*NH*NS + H*NS + S,
где  NH – число сторон  (головок );
NS – количество секторов на дорожке . Соответственно и обратное преобразование не составляет труда : имея  N,
делим его на  NS нацело , и получаем в остатке  S (номер сектора будет  S+1), а в
частном  N2 = С*NH + H. Делим нацело  N2 на NH, и в остатке получаем  H, а в
частном  – С.
Гораздо проще рассматривать диск не как набор из цилиндров , головок и
секторов , а как линейный одномерный массив секторов . В примере показано чтение первого сектора  (0-0-1) средствами  BIOS:
.model small
.stack 100h
.data
; опишем структуру для доступа к логическому диску
DRVPatam struc
c  dw ? ; максимальный номер сектора  (Sector)
DRVPatam ends
; блок параметров и буфер данных
block DRVPatam <?, ?, ?>
buf  db 512 dup (?) .code
.486
main:
mov ax, @data
mov ds, ax
; для начала следует определить параметры диска ...
; для преобразований номера сектора в координаты  C-H-S46
; собственно этого-то мы делать и не будем ...
; (просто считаем первый  (0-0-1) сектор !) mov ah, 08h ; функция
mov dl, 00h ; 00h-7Fh – гибкий диск , 80h-0FFh – жесткий диск
int 13h
mov al, ch ; выделим количество цилиндров  (дорожек )
mov ah, cl
shr ah, 6
inc ax
mov block.c, ax
and cx, 0111111b ; выделим количество секторов
mov block.s, cx
xor ah, ah ; количество головок  (сторон )
mov al, dh
inc ax
mov block.h, ax
; итак , читаем первый сектор  N=1 CHS(N)=0-0-1
mov ah, 2h  ; вторая функция биос  "тринадцать аш " – чтение сектора
mov al, 1   ; количество считываемых секторов
mov ch, 0   ; номер циллиндра  C
mov dh, 0   ; номер головки    H
mov cl, 1   ; номер сектора    S
mov dl, 00h ; 00h-7Fh – гибкий диск , 80h-0FFh – жесткий диск
push ds
pop  es     ; es=ds ! error:
mov ax, 4c00h
int 21h
end main
Как уже отмечалось , проще рассматривать диск как линейный одномерный
массив секторов . Теперь все адресные данные записываются в пакет  – область памяти , а не47
в регистры процессора , как было ранее . Примечание :этот способ чтения неприменим для дискеты , так как
воспринимаются только  EDD/ATA устройства  – жесткие диски и НГМД
большой емкости . ; количество передаваемых блоков :
; если  254 мало  – пишем сюда
                 ; 255(0FFh) и сколько
                 ; надо заносим в  nBlocksEx,
                 ; если и  2^32-2 мало  – вы в
                 ; далеком будущем ! –
; BIOS вечен  – он никуда не денется
; и в 64-х разрядных версиях
; процессоров , но будет иметь  3D
; графический интерфейс
; и станет понимать речь ...
nBlocksEx   dd ? ; если в  nBlocks количество блоков
; для передачи не входит ,
                 ; то... см. )48
.code
.486
main:
mov ax, @data
mov ds, ax
; определим параметры ...
mov block.packetSize, 32 ; размер структуры пакета
; дискового адреса
mov block.offs, offset buf ; сегментная часть адреса
;буфера
mov block.segm, ds    ; смещение буфеера в  block.segm
mov block.nBlocks, 1         ; считаем один сектор
mov dword ptr block.LBA[0],0 ; пока  32 разрядный  LBA
                          ; первого  (нулевого !) блока
 ;(сектора )
mov ah, 42h ; 42h – функция ! mov dl, 80h ; 80h-83h – жесткий диск
lea si, block ; DS:SI – адрес пакета
; дискового адреса
int 13h ; запуск сервиса  (надо бы
; проверить вначале  ;поддерживаются ли
; дополнительные функции )
test ah, ah ; вернула не ноль  – непорядок ! error:
mov ax, 4c00h
int 21h
end main
Считать/записать сектор можно и с помощью прерываний  DOS 25h ( прямое
чтение ) и 26h ( прямая запись ). Тонкость в использовании заключается в том , что
сервис различает не физические устройства , а разделы на диске  (логические
диски ), которые нумерует с нуля  (0-A:, 1-B:, 2-C:) и, кроме того , в силу
недостатков интерфейса  (см. пример ) не может адресовать больше  32 мегабайт в
логическом диске :
Пример низкоуровневого   обращения к диску средствами  DOS для
абсолютного чтения/записи49
;читаем первый сектор посредством  int 25h с дискеты
.model small
.stack 100h
.data
buf  db 512 dup (?) .code
.486
main:
mov ax, @data
mov ds, ax
mov al, 00h ; AL==00h логический диск  0-A:,
; 1-B:,
; 2-C:,...
mov cx, 1 ; число считываемых секторов
mov dx, 0 ; номер начального сектора
; 2^16*2^9=2^25=2^5
               ; мегабайт  (32 мегабайта максимум !) lea bx, buf    ; DS:BX – адрес буфера
int 25h        ; вызываем сервис
jc error
; первый сектор считан успешно ! error:
mov ax, 4c00h
int 21h
end main
Лишен недостатков сервис  DOS для работы с разделами большого размера . Подход тот же ,
что и в случае с  BIOS – создать блок параметров операции и передать сервису
адрес :
Пример низкоуровневого   обращения к диску средствами  DOS для
абсолютного чтения/записи  – работа с разделами большого объема . ; номер сектора  2^32 секторов50
                      ; 2^32*2^9=2^41=2^11 гигабайт  (2048 гигабайт ...)
nsectors  dw ? ; сегмент  – часть дальнего указателя на буфер
INT25Block ends
; блок параметров и буфер данных
block INT25Block <?, ?, ?, ?>
buf  db 512 dup (?) .code
.486
main:
mov ax, @data
mov ds, ax
mov block.sectorno, 0 ; номер считываемого сектора
mov block.nsectors, 1 ; количество считываемых секторов
mov block.offs, offset buf  ; смещение дальнего указателя на буфер
mov block.segm, ds          ; сегмент дальнего указателя на буфер
mov al, 02h        ; AL==00h логический диск 0-A:, 1-B:, 2-C:,...
mov cx, 0FFFFh     ; признак расширенной функции
lea bx, block      ; DS:BX – адрес блока описания операции чтения
int 25h            ; вызываем сервис
jc error
; успешно считан первый сектор диска  C:! error:
mov ax, 4c00h
int 21h
end main
3.2.2. VxD- драйвер  – это драйвер какого-либо51
устройства , работающий в привилегированном режиме микропроцессора . Согласно документации  MSDN, в
этих ОС корректно работает только функция чтения сектора логического диска
(не физического , как в случае с  MS-DOS). В связи с этим в примере будет
произведено считывание  0-го сектора диска  C: ( в программе предполагается , что
диск  C: имеет файловую систему  FAT32; на экран будет выведена информация из
этого сектора ). Выполнение обращения к дисковому устройству можно разделить на три
этапа :
1) открытие виртуального устройства  “VWin32” с помощью функции
“CreateFile”;
2) выполнение операции чтения сектора с помощью функции
“DeviceIOControl”;
3) вывод содержимого сектора на экран . Функция   CreateFile позволяет получить дескриптор  (hDevice) VxD-
драйвера , который будет использоваться функцией  DeviceIoControl. Описание аргументов данной функции уже давалось выше , поэтому
необходимо рассмотреть лишь то , как следует указать имя  VxD устройства
‘\\.\VxDName’ ( в данном случае  ‘\\.\VWin32’). Обратиться к драйверу устройства позволяет функция
BOOL DeviceIoControl(
   HANDLE hDevice, ; дескриптор  VxD – возвращенный
   ;CreateFile
   DWORD dwIoControlCode,// код выполняемой драйвером
                       // операции . DWORD nInBufferSize,// размер буфера входных
                        // данных  lpInBuffer в байтах
   LPVOID lpOutBuffer, //указатель на выходные  //данные
   DWORD nOutBufferSize, // размер буфера выходных
                        // данных  lpInBuffer в байтах
   LPDWORD lpBytesReturned, //указатель на двойное52
                             // слово  (после вызова
 //там количество полученных байт )
   LPOVERLAPPED lpOverlapped // указатель на
                // структуру  OVERLAPPED, необходимую
// для асинхронного ввода вывода
                // то есть вызвавший операцию процесс
                // не дожидается окончания ввода -
                // вывода , а продолжает выполнение
                // ( система уведомит процесс об
                // окончании операции послав
//определенное пользователем событие )
   );
push 0
push offset countb
push DEVIOCTL_REGISTERS_
push offset reg_EBX
push DEVIOCTL_REGISTERS_
push offset reg_EBX
push VWIN32_DIOC_DOS_DRIVEINFO
push eax
call DeviceIoControl ; stdcall
Кратко опишем возможности драйвера  VWIN32.VXD. dwIoControlCode Выполняемое  VWin32 действие
VWIN32_DIOC_DOS_DRIVEINFO Выполнить эквивалент  int 21h подмножество
функций  730Xh DOS
VWIN32_DIOC_DOS_INT13 Выполнить эквивалент  int 13h – доступ к
диску  BIOS
VWIN32_DIOC_DOS_INT25 Выполнить эквивалент  int 25h – абсолютное
чтение с диска  DOS
VWIN32_DIOC_DOS_INT26 Выполнить эквивалент  int 25h – абсолютная
запись на диск  DOS
VWIN32_DIOC_DOS_IOCTL Выполнить эквивалент определенной  DOS
функции ввода вывода  (int 21h функции
4400h-4411h)53
Параметры  lpInBuffer и должны  lpOutBuffer ссылаться на структуру
typedef struct _DIOC_REGISTERS {
    DWORD reg_EBX; // регистр процессора  EBX и т.д . DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags; // регистр флагов
};
Для вызова соответствующих сервисов надо ознакомится с их описанием и
сформировать в структуре  _DIOC_REGISTERS состояние регистров , которое
требовалась по спецификации для вызова сервиса . В некоторых случаях в сервисах
DOS (BIOS) требуется задавать дальние адреса структур в регистрах , например
ES:BX, а в структуре  _DIOC_REGISTERS сегментные регистры не присутствуют
вообще . Дело в том , что Windows, используя страничную адресацию , получает
«плоскую » четырех-гигабайтную память и базы всех дескрипторов в страничном
режиме настроены на начало памяти  (на 0). Пример низкоуровневого   обращения к диску в  Windows 95/98/ME
.386
.model flat, stdcall
locals
includelib ..\..\LIB\imp32i.lib
include ..\..\INCLUDE\w32.inc54
VWIN32_DIOC_DOS_DRIVEINFO equ 6
CARRY_FLAG       equ 1
.DATA
sVWin32 db "\\.\VWin32",0
sMsg1 db "Could not open VWin32!!! .CODE
Start:
pushad
;первый этап  – открываем виртуальное устройство  “VWin32”
push 0
push 0
push OPEN_EXISTING
push 0
push FILE_SHARE_READ or FILE_SHARE_WRITE
push GENERIC_READ
push offset sVWin3255
call CreateFile ; stdcall
cmp eax, INVALID_HANDLE_VALUE ; в случае ошибки
; CreateFile вернет
jz quit ; INVALID_HANDLE_VALUE
mov ebx, eax ; сохраняем в  ebx дескриптор
; открытого устройства
;второй этап  – чтение сектора
;заполняем необходимые поля структур
; см. документацию на  int 21h подмножество функций  730Xh DOS
;структура для чтения диска
mov StartSector, 0 ; номер сектора задаётся в формате  LBA
mov Sectors, 1
mov Buffer, offset Boot
;заполняем регистры в соответствии с изложенными выше правилами
;и документацией на  int 21h ax=730Xh
mov reg_EAX, 7305H
mov reg_EBX, offset StartSector ; на начало структуры  DISK_IO
mov reg_ECX, -1
mov reg_EDX, 3 ; 1=A:, 2=B:, 3=C:,  ...
; формирование стека для вызова  API функции  DeviceIoControl
push 0 ; нет асинхронного ввода/вывода–пустой указатель
push offset countb ; указатель на ячейку для количества считанных байт
push DEVIOCTL_REGISTERS_  ; размер входных данных
push offset reg_EBX ;на начало структуры  DEVIOCTL_REGISTERS
push DEVIOCTL_REGISTERS_  ; размер входных данных
push offset reg_EBX ;на начало структуры  DEVIOCTL_REGISTERS
push VWIN32_DIOC_DOS_DRIVEINFO; сервис  IOCTL
push eax ;дескриптор , полученный  CreateFile
call DeviceIoControl ; stdcall
test eax, eax ; в случае ошибки функция
; DeviceIoControl
jz quit ;вернет  false
test reg_Flags, CARRY_FLAG ; в случае ошибки в  reg_Fags
jz quit ; будет установлен флаг переноса
;мы успешно считали первый сектор  – можно работать дальше ! quit:
push  ebx
call CloseHandle ; закрываем устройство56
popad
push  0
call ExitProcess ; выходим из программы
END Start
Windows NT/2000/XP/2003/Vista
В операционной системе  Windows NT, а также в ОС построенных на основе
Windows NT работа с диском производится через функции работы с файлами
“CreateFile” и “ReadFile”, при этом пользователь , от лица которого выполняется
обращение к диску , должен обладать правами администратора . Выполнение программы можно разделить на три этапа :
1)открытие диска с помощью функции  “CreateFile”;
2)выполнение операции чтения сектора с помощью функции  “ReadFile”;
3)вывод содержимого таблицы разделов на экран . В качестве имени создаваемого файла следует указать :
1) для того чтобы открыть жесткий диск :
«\\.\PHYSICALDRIVEx» – где x – номер жесткого диска . 2) для того чтобы открыть раздел диска или НГМД :
«\\.\A:»  – вернет дескриптор гибкого диска
«\\.\C:» – вернет дескриптор раздела  «C:»
Полученный дескриптор можно использовать в функциях  ReadFile,
WriteFile, интерпретируя диск как файл большого объема . Дадим необходимую информацию по использованию функций
SetFilePointer и ReadFile (WriteFile):
DWORD SetFilePointer(
    HANDLE hFile, // дескриптор файла  (в нашем случае диска ) –
//результат работы  CreateFile57
    LONG lDistanceToMove, // количество байт на которое следует
//передвинуть файловый указатель чт/зп
    PLONG lpDistanceToMoveHigh, // если количество байт , на которое
// следует сдвинуть указатель больше  2^32,
//определить указатель на  64-битное смещение
//и передать в данном параметре указатель на него
    DWORD dwMoveMethod  // определяет относительно чего следует
// сдвигать файловый указатель
// FILE_BEGIN – смещение от начала  (DistanceToMove воспринимается
//как беззнаковое ); FILE_CURRENT – относительно текущего
// файлового указателя  (DistanceToMove воспринимается как число со
знаком и знак
//определяет куда  (вперед  + / назад  -) будет происходить сдвиг ); FILE_END-
// смещение от конца  (DistanceToMove воспринимается как беззнаковое )
   );
Для чтения необходимо использовать функцию  ReadFile. Прототип функции записи в
целом аналогичен и не приводится
BOOL ReadFile(
    HANDLE hFile, // дескриптор файла  (в нашем случае диска ) –
//результат работы  CreateFile
    LPVOID lpBuffer, // адрес буфера в памяти для чтения данных
    DWORD nNumberOfBytesToRead, // количество считываемых байт
    LPDWORD lpNumberOfBytesRead, // адрес ячейки для записи
// количества считанныхбайт
LPOVERLAPPED lpOverlapped  // указатель на структуру
//  OVERLAPPED, необходимую для асинхронного ввода -//
вывода , то есть вызвавший операцию процесс не
                           // дожидается окончания ввода-вывода , а
                           // продолжает выполнение  (система уведомит
                           // процесс об окончании операции , послав
                           // определенное пользователем событие )
   );58
Пример низкоуровневого   обращения к диску
в Windows NT/2000/XP/2003/Vista
Приведенный пример будет работать только под управлением ОС  Windows
NT/2000/XP/2003/ Vista. PARTENTRY ENDS
PARTENTRY_ equ 1+1+2+1+1+2+4+4
.DATA
sDrive db "\\.\PHYSICALDRIVE0",0 ; будем производить
; чтение с
; физического диска
.DATA? ; а сюда прочитанные данные
.CODE
Start:
pushad
;первый этап  – открытие диска
push 0
push 0
push OPEN_EXISTING
push 0
push FILE_SHARE_READ or FILE_SHARE_WRITE ;
;обязательно разрешить остальным писать на диск , а то59
;как же ОС будет работать ? push GENERIC_READ ; открываем диск на чтение
push offset sDrive
call CreateFile ; stdcall
cmp eax, INVALID_HANDLE_VALUE ; в случае ошибки
;“CreateFile” вернет  ; ;
;INVALID_HANDLE_VALUE
jz quit
mov ebx, eax ;сохраняем в ebx дескриптор второй этап  –
; выполняем чтение с диска
;позиционируемся в начало диска
push FILE_BEGIN ; от начала файла ДИСКА ! quit:
push  ebx
call CloseHandle ; закрыть указатель
popad
push 0
call ExitProcess
END Start
Вопросы для самопроверки
1.Главная загрузочная запись  (MBR). Причем , программы
разного типа выводить разным цветом  (например , .com – красным ,
.exe – белым , .txt – зеленым   и т. Вывести
на экран номер первого кластера обоих файлов
13 Вывести на экран информацию о том , какой диск и каталог являются
текущими , а также информацию о размере , кластера , сектора и о
размере свободного пространства на этом диске
14 Переименовать файл и добавить в него информацию . При этом
программы разного типа выводить разным цветом
16 Вывести на экран оглавление текущего каталога диска  A:, создать в
этом каталоге файл и вновь вывесит оглавление , используя разные
цветовые палитры
17 Вывести информацию о свободном и занятом пространстве на
дискете , используя информацию о свободных кластерах в  FAT
18 С помощью дескриптора файла , полученного из последней операции
открытия , установить текущую позицию файла через  1024 байта от
начала файла и вывести туда символьную строку . Вывести размер файла из записи в каталоге
24 Вывести на экран список удаленных файлов из текущего каталога ,
используя атрибуты цвета
25 Вывести на экран список удаленных файлов из корневого каталога
26 Вывести на экран список удаленных файлов из заданного каталога . О результате операции
вывести сообщение на экран , используя атрибуты цвета
28 Получить список кластеров , распределенных файлу
29 Вывести информацию о свободном месте на диске , используя
информацию о свободных кластерах в  FAT
30 Прочитать  MBR и вывести на экран содержимое таблицы разделов
со всеми атрибутами . 31 Прочитать содержимое корневого каталога и вывести список файлов
с обработкой  LFN
32 Прочитать содержимое корневого каталога и вывести список файлов
с атрибутами и датой создания
33 Прочитать из  MBR таблицу разделов и определить количество и
размеры логических дисков63
Библиографический список
1.Гордеев , А. В. Операционные системы : учеб . – 2- е изд . – 416 c.
2.Гордеев , А. В. Системное программное обеспечение : учеб . – СПб . – 736 c.
3.Юров , В. И. Assembler: учеб . – 2- е изд . – СПб . – СПб . – СПб . –
М.: Радио и связь , 1999. – М.: Радио и связь : Энтроп , 1999. – 382 c.: ил.64
Приложение
ФУНКЦИИ  DOS ДЛЯ РАБОТЫ С КЛАВИАТУРОЙ
INT 21h, Функция  01h – ввод с клавиатуры с эхо . INT 21h, Функция  06h – прямой ввод-вывод на консоль . На входе : AН = 06h
Регистр  AL используется для ввода , а регистр  DL – для вывода . INT 21h, Функция  07h – прямой ввод с клавиатуры без эхо . На выходе : AL – ASCII- код вводимого символа . INT 21h, Функция  08h – ввод с клавиатуры без эхо . На выходе : AL – ASCII- код вводимого символа . INT 21h, Функция  0Аh – буферизованный ввод с клавиатуры . На выходе : данные помещены в буфер в формате :
байт  0 – максимальное количество символов , которые
могут быть обработаны ;
байт  1 – фактическая длина введенной строки ;
 байт  2 и т.д . – строка , заканчивающаяся символом  0Dh.65
Функция дает возможность использовать в программе стандартные клавиши
для редактирования командной строки . Максимальное количество символов , которое можно поместить в буфер , на
единицу меньше значения его первого байта  – одна позиция зарезервирована для
символа  0Dh. INT 21h, Функция  0Вh – проверка входного статуса клавиатуры . На выходе : FFh, если есть символ на входном устройстве ;
 00h, если нет символа . INT 21h, Функция  0Сh – очистка входного буфера и ввод . На входе :  AH – 0Ch;
AL – номер функции ввода ;
DS:DX – адрес буфера  (если  AL=0Ah). На выходе : AL – байт входных данных  (если при вызове  AL=0Ah). ФУНКЦИИ  BIOS ДЛЯ РАБОТЫ С КЛАВИАТУРОЙ
INT 16h, Функция  00h – чтение очередного символа с клавиатуры . В AL получается скэн-код
символа , а в AH – позиционный код клавиши . INT 16h, Функция  01h – справка о наличии символа . На выходе : ZF=0, если в буфере клавиатуры есть символ ;
AH – скэн-код символа ;
AL – ASCII- код символа ;
ZF= 1, если буфер пуст .66
Определяет , имеются ли в кольцевом буфере ожидающие ввода символы . INT 16h, Функция  02h – информация о состоянии . ФУНКЦИИ  DOS ДЛЯ ВЫВОДА ИНФОРМАЦИИ НА ЭКРАН
INT 21h, Функция  02h – вывод символов на экран через стандартный поток . INT 21h, Функция  06h – прямой ввод-вывод на консоль . INT 21h, Функция  09h – вывод строки на экран дисплея . Функция обрабатывает нажатие клавиш  Ctrl-Break.67
ФУНКЦИИ  BIOS ДЛЯ ВЫВОДА ИНФОРМАЦИИ НА ЭКРАН
INT 10h, Функция  00h – выбор режима работы . INT 10h, Функция  01h – изменение формы курсора . На входе :  AH – 01h;
CH – верхняя граница курсора ;
CL – нижняя граница курсора . INT 10h, Функция  02h – изменение положения курсора . На входе :  AH – 02h;
BH – номер страницы видеопамяти ;
DH – номер строки ;
DL – номер столбца . INT 10h, Функция  03h – определение положения и формы курсора . На входе :  AH – 03h;
BH – номер страницы видеопамяти . INT 10h, Функция  05h – изменение активной страницы видеопамяти . На входе :  AH – 05h;
AL – номер страницы видеопамяти , которая станет активной . INT 10h, Функция  06h – перемещение текстового окна вверх . На входе : AH – 06h;
AL - число строк для перемещения ;
если  AL=0, то окно очищается целиком . BH - атрибут цвета для строк , возникающих снизу окна ;
CL - строка и столбец верхнего левого угла окна ;68
DH и DL – строка и столбец нижнего правого угла окна . INT 10h, Функция  07h – перемещение текстового окна вниз . На входе : AH – 07h;
AL – число строк для перемещения ,
если  AL=0, то окно очищается целиком ;
BH – атрибут цвета для строк , возникающих снизу окна ;
CH и CL – строка и столбец верхнего левого угла окна ;
DH и DL – строка и столбец нижнего правого угла окна . INT 10h, Функция  08h – чтение символа и его атрибутов . На входе :  AH – 08h;
BH – номер страницы видеопамяти . INT 10h, функция  09h – запись символа с атрибутами в текущей позиции курсора . На входе :  AH – 09h;
AL –  ASCII- код записываемого символа ;
BH –  номер страницы видеопамяти ;
BL –  атрибут для текстового режима или
цвет для графического режима ;
CX – число записываемых символов . INT 10h, функция  0Ah – запись символа в текущей позиции курсора . На входе :  AH –  0Ah;
AL –  ASCII- код записываемого символа ;
BH –  номер страницы видеопамяти ;
BL –  цвет  (для графического режима );
CX –  число записываемых символов .69
Можно производить запись нескольких одинаковых символов на любой
странице видеопамяти . INT 10h, функция  0Сh – вывод пикселя . На входе :  AH –  0Ch;
AL –  номер цвета ;
BH -  номер страницы ;
 DL – номер строки от  0 до 199;
CX -  номер столбца от  0 до 319 или до  639. INT 10h, функция  0Dh – чтение пикселя . На входе :  AX –  0Dh;
 BH – номер страницы ;
СХ – номер столбца ;
DХ – номер строки . INT 10h, функция  0Еh – запись символа в режиме телетайпа . На входе :  AH –  0Eh;
AL –  ASCII- код записываемого символа ;
 BH – номер страницы видеопамяти  (только в текстовых
режимах );
BL – цвет символа в графических режимах . INT 10h, функция  0Fh – определение текущего режима работы видеоадаптера ,
номера активной страницы и количества символов в строке экрана . Hа входе :  AH – 0Fh.70
На выходе : AH -  число символов в строке ;
AL – номер текущего режима ;
BH – номер активной странице видеопамяти . INT 10h, функция  13h – вывод текстовой строки . Hа входе :  AH –  13h;
AL – режим отображения строки :
0 – курсор не перемещается , атрибуты символов
      в строке одинаковы ;
1 – курсор перемещается , атрибуты символов в
      строке одинаковы ;
2 – курсор не перемещается , атрибуты каждого
      символа задаются отдельно ;
3 – курсор перемещается , атрибуты каждого
      символа задаются отдельно ;
ВН – номер страницы видеопамяти ;
BL – атрибут , если  AL содержит  0 или 1;
СХ – длина строки ;
DH – номер строки экрана , в которой отображается
строка ;
ES:BP – адрес строки в оперативной памяти . При этом сначала
идет символ , а затем его атрибут .71
ФУНКЦИИ  DOS ДЛЯ РАБОТЫ С ФАЙЛАМИ , КАТАЛОГАМИ
И ДИСКАМИ
INT 21h, Функция  0Dh – очищение дисковых буферов . INT 21h, Функция  0Eh – смена текущего диска . На выходе : AL – максимальное количество логических дисков,как оно
определено командой  LASTDRIVE в CONFIG.SYS. INT 21h, Функция  19h – получение текущего диска . INT 21h, Функция  1Ah – изменение адреса области обмена с диском . На входе :  AH – 19h;
DS:DX – адрес  DTA ( область обмена с диском ). INT 21h, Функция  1Bh – информация о текущем диске . На выходе : AL – количество секторов в кластере ;
CX – количество байтов в секторе ;
DX – общее количество кластеров на диске ;
DS:BX – указатель к идентификатору формата диска :
FD – дискета  360 Кбайт ;
F9 – дискета  1.2 Мбайт ;
FB – дискета  1.44 Мбайт ;
F8 – жесткий диск . INT 21h, Функция  1Сh – информация о заданном диске . На входе :  AH – 1Ch;
DL – номер диска  (0 – текущий , 1 – А и т.д . ). На выходе : AL – количество секторов в одном кластере ;
DX – количество кластеров на диске ;
CX – размер сектора ;
DS:BX – указатель к идентификатору формата диска . DS:BX содержит адрес одного байта в рабочих областях  DOS, который
является копией идентификатора формата диска из  FAT. INT 21h, Функция  1Fh – получение адреса блока параметров текущего диска .72
На входе :  AH – 1Fh. На выходе : AL – 00h – успешное выполнение ;
 DS:BX – адрес блока параметров диска . INT 21h, Функция  2Еh – проверка при записи на диск . INT 21h, Функция  32h – получение адреса блоков параметров заданного диска . На входе :  AH – 32h;
DL – номер диска . На выходе : AL – 00h – успешное выполнение ;
AL – FFh – недопустимый дисковод ;
DS:BX – адрес блока параметров диска . INT 21h, Функции  33h, подфункция  05h – получение дисковода загрузки . На выходе : DL – дисковод загрузки  (1=А:, и т.д . ). На входе :  AH – 36h;
DL – номер диска . На выходе : ВХ – количество свободных кластеров ;
 DX – общее количество кластеров на диске ;
 СХ – размер сектора  (в байтах );
 АХ – количество секторов в одном кластере ,
FFFFh, если номер диска в  DL недействителен . INT 21h, Функция  39h – создание каталога  (МкDir). INT 21h, Функция  3Аh – удаление каталога  (RmDir). INT 21h, Функция  3Вh – смена каталога  (СhDir). На входе :  АН – номер функции ;
DS:DX – указатель к  ASCIIZ- цепочке . На выходе : АХ – код ошибки , если  CF=1. Функции аналогичны соответствующим командам  DOS – MD, RD и CD. INT 21h, Функция  3Сh – создание файла  (CREATE).73
На входе :   АН – 3Ch;
 DS:DX – указатель к  ASCIIZ- цепочке ;
 СХ (CL) – атрибуты файла . На выходе : АХ – код ошибки , если  CF=1;
файловый дескриптор , если  CF=0. INT 21h, Функция  3Dh – открытие файла  (OРEN). На входе :   АН – 3Dh;
 DS:DX – указатель к  ASCIIZ- цепочке ;
 AL – режим открытия  (код доступа ). На выходе : АХ – код ошибки , если  CF=1;
файловый дескриптор , если  CF=0. Определяют права доступа программы к
файлу : (000) – только для чтения ; (001) – только для записи ; (010) – для чтения и
записи . Возможны следующие коды ошибок : 2 – файл не
обнаружен ; 3 – нет такого пути ; 4 – нет свободного файлового дескриптора ; 5 –
отказан доступ ; 12 – недействительный код доступа . INT 21h, Функция  3Eh – закрытие файла  (СLOSE). На входе : АН – 3Eh.74
DS:DX – файловый дескриптор  (полученный при открытии или
создании файла ). На выходе : АХ – код ошибки , если  CF=1. На входе :  АН – номер функции ;
ВХ – файловый дескриптор , полученный при   открытии или
создании файла ;
СХ: – количество байтов  (размер записи );
DS:DX – адрес , по которому нужно записать прочитанную
запись . На выходе : АХ – код ошибки , если  CF=1
или количество действительно прочитанных   (записанных )
байтов . Например , при
достижении конца файла или при чтении с клавиатуры можно прочесть максимум
одну строку  (до нажатия  Enter), независимо от указанного количества байтов для
чтения . INT 21h, Функция  41Н – удаление файла . На входе :  АН – 41h;
 DS:DX – указатель к  ASCIIZ- цепочке . На выходе : АХ – код ошибки , если  CF=1. INT 21h, Функция  42h – перемещение текущего указателя в файле . На входе :  АН – 42h;
ВХ – файловый дескриптор , полученный при открытии или
создании файла ;
СХ:DX – смещение относительно текущей позиции в байтах
интерпретируется как  32-битовое целое число без знака ;
AL – метод перемещения . На выходе : АХ – код ошибки , если  CF=1;
  DX:AX – новое значение указателя ;
  AL может иметь следующие значения :
0 – смещение считается от начала файла . Если
CX:DX=0, то Fр указывает на начало файла ;
1 –  смещение считается от текущей позиции  Fр;75
2  –  смещение считается от конца файла . Если
CX:DX=0, то в  DX:AX получается длина файла в
байтах . Возможны следующие коды ошибок : 1 – недействительный номерфункции ;
6 – недействительный файловый дескриптор . На входе :  АН – 43h;
 DS:DX – указатель к  ASCIIZ- цепочке ;
 СХ – атрибуты файла ;
 АL – 00 – информация об атрибутах ;
01 – изменение атрибутов . На выходе : АХ – код ошибки , если  CF=1;
СХ – атрибуты файла , если  CF=0 и на входе  AL=00h. Коды ошибок : 1 – недействительная функция ; 2 – файл не
обнаружен ; 3 – нет такого пути ; 5 – отказан доступ . INT 21h, Функция  47h – информация о текущем каталоге . На входе :  АН – 47h;
 DL – код дисковода ;
 DS:SI – адрес буфера длиной  64 байта . На выходе : АХ – код ошибки , если  CF=1;
DS:SI – по этому адресу записывается полная файловая
спецификация текущего каталога . На входе :  АН – 4Eh;
 DS:DX – указатель к  ASCIIZ- цепочке  ( файловая
спецификация );
 СХ – атрибуты файла , используемые при поиске . На выходе : АХ – код ошибки , если  CF=1. При обнаружении файла  DTA ( байты  1Eh – 2Ah) заполняется
следующей информацией :
21 байт  – зарезервированы для последующего поиска функцией  4FH;
 1 байт  – атрибуты файла ;
1 – только для чтения ;
2 – скрытый ;
4 – системный ;
8 – метка тома ;76
10h – каталог ;
20h – атрибут архивации ;
 2 байта  – время  (из каталога );
 2 байта  – дата (из каталога );
 2 байта  – размер файла  (младшая часть );
 2 байта  – размер файла  (старшая часть );
 13 байт  – имя обнаруженного файла . На входе :  АН – 56h;
 DS:DX – указатель к  ASCIIZ- цепочке   – старое имя ;
 ЕS:DI – указатель к  ASCIIZ- цепочке   – новое имя . На выходе : АХ – код ошибки , если  CF=1. INT 21h, Функция  5Аh – создание временного  (уникального ) файла . INT 21h, Функция  5Вh – создание нового файла . На входе :  АН – номер функции ;
 DS:DX – указатель к  ASCIIZ- цепочке ;
 СХ (CL) – атрибуты файла . На выходе : АХ – код ошибки , если  CF=1;
 файловый дескриптор , если  CF=0. INT 21h, Функция  68h – Сбросить в файл . На выходе : АХ – код ошибки , если  CF=1. Функция будет выполняться и при недостаточном числе
дескрипторов , и прикладная программа не рискует потерять управление файлом в
многозадачных или сетевых средах .77
INT 21h, Функция  69h – получение или установка серийного номера тома . На входе :  AH – 69h;
 AL –  00h – получить серийный номер ;
 01h – установить серийный номер ;
 BL – дисковод ;
 DS:DX – адрес буфера размером  32 байта . На выходе : при AL=00h в буфер помещается копия содержимого
расширенного блока параметров  BIOS (B рB) на диске ;
 при AL=01h в расширенный  BрB на диске копируется
информация из буфера ;
 АХ – код ошибки , если  CF=1. INT 21h, Функция  6Ch – расширенное открытие файла . На входе :  AL – 00h;
 BX – режим открытия ;
 CX – атрибут файла ;
 DX – флаг открытия ;
 DS:SI – адрес пути , заданного в коде  ASCIIZ;
На выходе АХ  –  дескриптор , если  CF=0;
 код ошибки , если  CF=1;
СХ -  1 – файл существовал и был открыт ;
 2 – файл не существовал и был создан ;
 3 – файл существовал и был заменен . Функция не выполняется , если
– не существует какого-либо элемента пути ;
– если файл создается в корневом каталоге , который переполнен ;
– если в заданном каталоге уже существует файл с тем же именем , что и
создаваемый файл , и с атрибутом только для чтения ;
– если программа выполняется в сети , а пользователь программы имеет
недостаточные права доступа . На входе :   AL – номер дисковода  (0=А, 1=В и т.д .) СХ – -1;
 DS:BX – адрес блока параметров следующего формата :
00h-03h – 32- битный номер сектора ;78
04h-05h – число секторов для чтения ;
06h-07h – относительный адрес буфера ;
08h-09h – сегмент буфера . На выходе : АХ – код ошибки , если  CF=1. Младший байт  (AL) совпадает с кодом ошибки , возвращаемым в младший
байт регистра  DI, и может принимать следующие значения :
 00h – ошибка защиты записи ;
 01h – неизвестное устройство ;
 02h – дисковод не готов ;
 03h – неизвестная команда ;
 04h – ошибка данных  (CRC);
 06h – ошибка позиционирования ;
 07h – неизвестный тип носителя ;
 08h – сектор не найден . Старший байт  (АН) содержит :
 01h – неправильная команда ;
 02h – неправильная метка адреса ;
 03h – попытка записи на защищенный диск  (26Н);
 04h – запрашиваемый сектор не найден ;
 08h – не выполнен прямой доступ к памяти ;
 10h – ошибка данных ;
 20Н – не сработал контроллер ;
 40h – не выполнена операция установки ;
 80h – подсоединенное устройство не среагировало ;79
ФУНКЦИИ  BIOS ДЛЯ РАБОТЫ С ДИСКАМИ
INT 13h, Функции  00h – сброс контроллера  (Reset). Поэтому при выполнении операции  BIOS
обнуляет биты  0 – 3 байта по адресу  43Еh (бит 0 относится к устройству А , бит 1
– к устройству В и т.д . ). Если он равен  0,
то перед операцией головка позиционируется на дорожке  0 (рекалибровка ), после
чего выполняется операция и в соответствующий бит записывается  1. INT 13h, Функция  01h – получить состояние дисковой системы . На входе :  DL – дисковод :  00 Н – 07 Н – гибкий диск ;
80Н – FFH – жесткий диск ;
 AL = 00h – операция выполнена успешно ;
 01h – недействительная команда ;
 02h – не обнаружено или ошибочно адресное поле ;
 03h – попытка записи на защищенную дискету ;
 04h – сектор не обнаружен ;
 05h – сброс в исходное состояние не выполнен  (Ж);
 06h – гибкий диск снят  (Г);
 07h – дефектная таблица параметров  (Ж);
 08h – нарушение границ ПДП  (Г);
 09h – ПДП  (DMA) пересек границу  64 Кбайт ;
 0Аh – флаг дефектного сектора  (Ж);
 0Вh – флаг дефектной дорожки  (Ж);
 0Сh – не найден тип носителя  (Г);
 0Dh – недопустимое число секторов при форматировании
(Ж);
 0Fh – обнаружена метка адреса управляющих данных ;
 10h – невосстановимая ошибка циклического контроля
или ошибка кода проверки и корректировки данных
по избыточности  (CRC);
 11h – ошибка данных скорректирована кодом проверки и
корректировки  (Ж) (обнаружение восстановимой80
ошибки в процессе предшествующего чтения
сектора );
 20h – отказ контроллера ;
 40h – сбой поиска ;
 80h – нет ответа от устройства  (тайм-аут );
 AAh – дисковод не готов  (Ж);
 BBh – неопределенная ошибка  (Ж);
 ССh – отказ записи  (Ж);
 Е0h – ошибка регистра состояния  (Ж);
 FFh – операция опознания не выполнилась  (Ж);
INT 13h,  Функция  02h – чтение секторов . На входе :  AH – номер функции ;
 DL – номер устройства  (0–3);
 DH – сторона дискеты  (0–1);
 CH – номер дорожки ;
 CL – номер первого сектора ;
 AL – число секторов для чтения  (записи );
 ES:BX – адрес входного  (выходного ) буфера  (не используется
функцией  04Н). INT 13h, Функция  05h – форматирование дорожки . На входе :  AH – 05h;
 DL – номер устройства  (0–3);
 DH – сторона дискеты  (0–1);
 CH – цилиндр ;
 AL – число секторов для форматирования ;
 ES:BX – адрес буфера . Для каждого сектора готовятся  4 байта , которые его описывают  – так называемое
адресное поле . Четыре байта
адресного поля имеют обозначения :
 С – цилиндр ;
 Н – головка  (номер поверхности );
 R – запись  (номер сектора );
 N – код размера сектора  (без адресного поля ).81
При форматировании адресные поля тоже записываются на дорожку в
начале соответствующего сектора . INT 13h, Функция  10h – получить состояние дисковода . На входе :  AH – 10h;
 DL: 80 Н – FFH жесткий диск . На выходе : АН – 0, если  SF=0;
 АН – код ошибки , если  CF=1 (c м. функцию  01Н). INT 13h, Функция  15h – получить тип дисковода . На выходе : АН – код типа дисковода :
 00h – дисковод отсутствует ;
 01h – используется дисковод гибкого диска без
поддержки сигнала смены носителя ;
 02h – используется дисковод гибкого диска с поддержкой
сигнала смены носителя ;
 03h – используется жесткий диск , в этом случае :
 CX:DX – число  512- байтный секторов ;
 АН – код ошибки , если  CF=1 (c м. функцию  01Н);
Возвращает код указанного дисковода , соответствующий типу гибкого или
жесткого диска .82
Учебное издание
Караваева Ольга Владимировна
Системные программные средства
для управления вводом-выводом .